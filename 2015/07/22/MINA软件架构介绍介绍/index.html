<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>MINA软件架构介绍介绍 | 杨超的程序世界</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Mina项目介绍Mina静态分析（代码结构，类图之类的）Mina动态分析（运行时内存布局，资源占用，通信协议一类的）
http://www.slideshare.net/osi/apache-mina-the-highperformance-protocol-construction-toolkit
在图中的模块链中，IoService 便是应用程序的入口，相当于我们前面代码中的 IoAccept">
<meta property="og:type" content="article">
<meta property="og:title" content="MINA软件架构介绍介绍">
<meta property="og:url" content="http://sakuyayc.github.io/sakuyayc/2015/07/22/MINA软件架构介绍介绍/index.html">
<meta property="og:site_name" content="杨超的程序世界">
<meta property="og:description" content="Mina项目介绍Mina静态分析（代码结构，类图之类的）Mina动态分析（运行时内存布局，资源占用，通信协议一类的）
http://www.slideshare.net/osi/apache-mina-the-highperformance-protocol-construction-toolkit
在图中的模块链中，IoService 便是应用程序的入口，相当于我们前面代码中的 IoAccept">
<meta property="og:updated_time" content="2015-07-22T13:07:26.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MINA软件架构介绍介绍">
<meta name="twitter:description" content="Mina项目介绍Mina静态分析（代码结构，类图之类的）Mina动态分析（运行时内存布局，资源占用，通信协议一类的）
http://www.slideshare.net/osi/apache-mina-the-highperformance-protocol-construction-toolkit
在图中的模块链中，IoService 便是应用程序的入口，相当于我们前面代码中的 IoAccept">
  
    <link rel="alternative" href="/atom.xml" title="杨超的程序世界" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/sakuyayc/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">杨超的程序世界</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">数据可视化、分布式、软件工程</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://sakuyayc.github.io/sakuyayc"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-MINA软件架构介绍介绍" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/sakuyayc/2015/07/22/MINA软件架构介绍介绍/" class="article-date">
  <time datetime="2015-07-22T13:06:03.000Z" itemprop="datePublished">2015-07-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      MINA软件架构介绍介绍
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Mina项目介绍<br>Mina静态分析（代码结构，类图之类的）<br>Mina动态分析（运行时内存布局，资源占用，通信协议一类的）</p>
<p><a href="http://www.slideshare.net/osi/apache-mina-the-highperformance-protocol-construction-toolkit" target="_blank" rel="external">http://www.slideshare.net/osi/apache-mina-the-highperformance-protocol-construction-toolkit</a></p>
<p>在图中的模块链中，IoService 便是应用程序的入口，相当于我们前面代码中的 IoAccepter，IoAccepter 便是 IoService 的一个扩展接口。IoService 接口可以用来添加多个 IoFilter，这些 IoFilter 符合责任链模式并由 IoProcessor 线程负责调用。而 IoAccepter 在 ioService 接口的基础上还提供绑定某个通讯端口以及取消绑定的接口。在上面的例子中，我们是这样使用 IoAccepter 的：<br>IoAcceptor acceptor = new SocketAcceptor();</p>
<p>相当于我们使用了 Socket 通讯方式作为服务的接入，当前版本的 MINA 还提供了除 SocketAccepter 外的基于数据报文通讯的 DatagramAccepter 以及基于管道通讯的 VmPipeAccepter。另外还包括串口通讯接入方式，目前基于串口通讯的接入方式已经在最新测试版的 MINA 中提供。你也可以自行实现 IoService 接口来使用自己的通讯方式。<br>而在上图中最右端也就是 IoHandler，这便是业务处理模块。相当于前面例子中的 HelloHandler 类。在业务处理类中不需要去关心实际的通讯细节，只管处理客户端传输过来的信息即可。编写 Handler 类就是使用 MINA 开发网络应用程序的重心所在，相当于 MINA 已经帮你处理了所有的通讯方面的细节问题。为了简化 Handler 类，MINA 提供了 IoHandlerAdapter 类，此类仅仅是实现了 IoHandler 接口，但并不做任何处理。</p>
<p>一个 IoHandler 接口中具有如下一些方法（摘自 MINA 的 API 文档）：<br>void exceptionCaught(IoSession session, Throwable cause)<br>                   当接口中其他方法抛出异常未被捕获时触发此方法<br>void messageReceived(IoSession session, Object message)<br>                   当接收到客户端的请求信息后触发此方法.<br>void messageSent(IoSession session, Object message)<br>                   当信息已经传送给客户端后触发此方法.<br>void sessionClosed(IoSession session)<br>                   当连接被关闭时触发，例如客户端程序意外退出等等.<br>void sessionCreated(IoSession session)<br>                   当一个新客户端连接后触发此方法.<br>void sessionIdle(IoSession session, IdleStatus status)<br>                   当连接空闲时触发此方法.<br>void sessionOpened(IoSession session)<br>                   当连接后打开时触发此方法，一般此方法与 sessionCreated 会被同时触发</p>
<p>前面我们提到 IoService 是负责底层通讯接入，而 IoHandler 是负责业务处理的。那么 MINA 架构图中的 IoFilter 作何用途呢？答案是你想作何用途都可以。但是有一个用途却是必须的，那就是作为 IoService 和 IoHandler 之间的桥梁。IoHandler 接口中最重要的一个方法是 messageReceived，这个方法的第二个参数是一个 Object 型的消息，总所周知，Object 是所有 Java 对象的基础，那到底谁来决定这个消息到底是什么类型呢？答案也就在这个 IoFilter 中。在前面使用的例子中，我们添加了一个 IoFilter 是 new ProtocolCodecFilter(new TextLineCodecFactory())，这个过滤器的作用是将来自客户端输入的信息转换成一行行的文本后传递给 IoHandler，因此我们可以在 messageReceived 中直接将 msg 对象强制转换成 String 对象。<br>而如果我们不提供任何过滤器的话，那么在 messageReceived 方法中的第二个参数类型就是一个 byte 的缓冲区，对应的类是 org.apache.mina.common.ByteBuffer。虽然你也可以将解析客户端信息放在 IoHandler 中来做，但这并不是推荐的做法，使原来清晰的模型又模糊起来，变得 IoHandler 不只是业务处理，还得充当协议解析的任务。<br>MINA自身带有一些常用的过滤器，例如LoggingFilter（日志记录）、BlackListFilter（黑名单过滤）、CompressionFilter（压缩）、SSLFilter（SSL加密）等。</p>
<p>首先，看Mina在项目中所处的位置，如下图：</p>
<p>Mina处于中间层，它不关心底层网络数据如何传输，只负责接收底层数据，过滤并转换为Java对象提供给我们的应用程序，然后把应用程序响应值过滤并转换为底层识别的字节，提供给底层传输；<br>———总之：Mina是底层数据传输和用户应用程序交互的接口！<br>Mina工作流程图如下：</p>
<p>这个流程图不仅很直观的看出了Mina的工作流程，也涵盖了Mina的三个核心接口:IoService接口，IoFilter接口和IoHandler接口：<br>λ    第一步. 创建服务对象（客户端或服务端）  —-IoService接口实现<br>λ    第二步. 数据过滤（编码解码等）          —-IOFilter接口实现<br>λ    第三步. 业务处理                        —-IoHandler接口实现</p>
<p>   Mina的精髓是IOFilter，它可以进行日志记录，信息过滤，编码解码等操作，把数据接收发送从业务层独立出来。<br>   创建服务对象，则是把NIO繁琐的部分进行封装，提供简洁的接口。<br>   业务处理是我们最关心的部分，跟普通的应用程序没任何分别。</p>
<p>2.1.IoService接口<br>作用：IoService是创建服务的顶层接口，无论客户端还是服务端，都是从它继承实现的。<br>2.1.1 类结构<br>常用接口为：IoService，IoAcceptor，IoConnector<br>常用类为：NioSocketAcceptor，NioSocketConnector<br>类图如下：</p>
<p>先提出两个问题：</p>
<ol>
<li>为什么有了IoService接口还要定义AbstractIoService抽象类？</li>
<li>AbstractIoService抽象类与IoAcceptor(IoConnector)有什么区别？<br>分析：<br>λ    IoService接口声明了服务端的共有属性和行为；<br>λ    IoAcceptor接口继承了IoService接口，并添加了服务端特有的接口属性及方法，比如bind（）方法，成为典型的服务端接口；<br>λ    IoConnector接口同样继承了IoService接口，并添加了客户端特有的接口属性及方法，比如connect（）方法，成为典型的客户端接口；<br>—— IoService是IoAcceptor和IoConnector父接口，为什么不直接定义IoAcceptor和IoConnector接口呢，因为它们有共同的特点，比如共同属性，管理服务的方法等，所有IoService的出现是为了代码复用。<br>λ    AbstractIoService实现了IoService中管理服务的方法，比如getFilterChainBuilder方法—-获得过滤器链；<br>——为什么有了IoService接口还要定义AbstractIoService抽象类？一样为了代码的复用！AbstractIoService抽象类实现了服务端或客户端的共有的管理服务的方法，不需要让IoService接口的子类重复的实现这些方法；<br>λ    AbstractIoService抽象类继承了AbstractIoService抽象类并实现了IoAcceptor接口，成为了拥有管理服务端实现功能的服务端类；我们常用的NioSocketAcceptor就是它的子类；<br>λ    AbstractIoConnector抽象类继承了AbstractIoService抽象类并实现了IoConnector接口，成为了拥有管理客户端实现功能的客户端类；我们常用的NioSocketConnector就是它的子类；<br>——AbstractIoService抽象类与IoAcceptor(IoConnector)有什么区别？很清楚，AbstractIoService抽象类实现的是共有的管理服务的方法，只有管理功能的一个类；而两个接口却是不同的两个服务角色——一个客户端，一个服务端。<br>2.2.IoFilter接口<br>Mina最主要的工作就是把底层传输的字节码转换为Java对象，提供给应用程序；或者把应用程序返回的结果转换为字节码，交给底层传输。这些都是由IoFilter完成的，因此IoFilter是Mina的精髓所在。<br>在Mina程序中，IoFilter是必不可少的；有了它，Mina的层次结构才异常清晰：<br>IoFilter   ——   消息过滤<br>IoHandler  ——   业务处理<br>Filter，过滤器的意思。IoFilter，I/O操作的过滤器。IoFilter和Servlet中的过滤器一样，主要用于拦截和过滤网络传输中I/O操作的各种消息。在Mina 的官方文档中已经提到了IoFilter 的作用：<br>（1）记录事件的日志（Mina默认提供了LoggingFilter）<br>（2）测量系统性能<br>（3）信息验证<br>（4）过载控制<br>（5）信息的转换(主要就是编码和解码)<br>（6）和其他更多的信息<br>IoService实例会绑定一个DefaultIoFilterChainBuilder —— 过滤器链，我们把自定义的各种过滤器（IoFilter）自由的插放在这个过滤器链上了，类似于一种可插拔的功能！<br>2.2.1 类结构<br>常用接口为：IoFilter，IoFilterChainBuilder<br>常用类为：IoFilterAdapter，DefaultIoFilterChainBuilder<br>ProtocolCodecFilter，LoggingFilter<br>类图如下：</li>
</ol>
<p>总结<br>    IoFilter是转码和解码用滴，它是Mina最值得研究的地方，建议阅读它的源码！<br>    在实际的应用开发中，自定义协议是必用的，因为很多客户端和服务端是不同语言实现的。<br>2.3.IoHandler接口<br>    IoHandler是Mina实现其业务逻辑的顶级接口；它相当简单，你就理解它是根据事件触发的简单应用程序即可。<br>在IoHandler中定义了7个方法，根据I/O事件来触发对应的方法：<br>import java.io.IOException;<br>public interface IoHandler {<br>    void sessionCreated(IoSession session) throws Exception;<br>    void sessionOpened(IoSession session) throws Exception;<br>    void sessionClosed(IoSession session) throws Exception;<br>    void sessionIdle(IoSession session, IdleStatus status) throws Exception;<br>    void exceptionCaught(IoSession session, Throwable cause) throws Exception;<br>    void messageReceived(IoSession session, Object message) throws Exception;<br>    void messageSent(IoSession session, Object message) throws Exception;<br>}<br>sessionCreated:当一个新的连接建立时，由I/O processor thread调用；<br>sessionOpened:当连接打开是调用；<br>messageReceived:当接收了一个消息时调用；<br>messageSent：当一个消息被(IoSession#write)发送出去后调用；<br>sessionIdle:当连接进入空闲状态时调用；<br>sessionClosed:当连接关闭时调用；<br>exceptionCaught:当实现IoHandler的类抛出异常时调用；<br>一般情况下，我们最关心的只有messageReceived方法，接收消息并处理，然后调用IoSession的write方法发送出消息！（注意：这里接收到的消息都是Java对象，在IoFilter中所有二进制数据都被解码啦！）<br>    一般情况下很少有人实现IoHandler接口，而是继承它的一个实现类IoHandlerAdapter，这样不用覆盖它的7个方法，只需要根据具体需求覆盖其中的几个方法就可以！</p>
<p>Iohandler的7个方法其实是根据session的4个状态值间变化来调用的：<br>λ    Connected：会话被创建并使用；<br>λ    Idle：会话在一段时间(可配置)内没有任何请求到达，进入空闲状态；<br>λ    Closing：会话将被关闭（剩余message将被强制flush）；<br>λ    Closed：会话被关闭；<br>状态转换图如下：</p>
<p>一．    Mina解析<br>Java NIO是相对于传统的IO操作而言的，因为提出了缓冲池等概念，使它的处理数据的效率大大提高；<br>多线程是并发处理的明智选择；为减少系统开销，线程池是并发应用中是经常使用的技术；<br>而异步处理机制可以大大缩短每个请求的响应时间；<br>Mina2中就大量使用了这三项技术，使得它成为优秀的网络应用框架。<br>（这一章并非描述Mina的实际应用，而是对它的内部处理机制做分析；但是本人水平有限，可能有的观点并非正确滴，错误之处望多指正，更希望能邮件联系沟通；<br>我们对Mina的解析也只对服务端而言：因为无论是Mina也好，NIO也好，多线程也好，异步处理机制也好，都是解决高并发问题的；高并发却是对服务端而言的！因此，服务端才是重点呀。）<br>3.1 NIO分析<br>Mina是一个Java NIO框架；而NIO的基本思想是：服务器程序只需要一个线程就能同时负责接收客户的连接、客户发送的数据，以及向各个客户发送响应数据。服务器程序的处理流程如下：<br>//阻塞<br>while(一直等待，直到有接收连接就绪事件、读就绪事件或写就绪事件发生){<br>if(有客户连接)<br>    接收客户的连接;  //非阻塞<br>if(某个Socket的输入流中有可读数据)<br>    从输入流中读数据;  //非阻塞<br>if(某个Socket的输出流可以写数据)<br>    向输出流写数据;  //非阻塞<br>}<br>而传统的并发型服务器则是采用多线程的模式响应用户请求的；<br>//阻塞<br>while(一直等待){<br>if(有客户连接)<br>    启动新线程，与客户的通信;  //可能会阻塞<br>}<br>    但是，无论如何，服务端共同的结构如下：</p>
<ol>
<li>Read Request；   接受请求</li>
<li>Decode Request； 请求值解码(读)</li>
<li>Process Service；请求处理</li>
<li>Encode Reply；   响应值编码(写)</li>
<li>Send Reply；     发送响应</li>
</ol>
<p>1.1.1    多线程阻塞服务器<br>在实际的应用开发中，我们更多采用的是多线程阻塞服务器，即每一个客户端请求到达，就建立一个线程单独的处理它与服务端的通信，如下图所示：</p>
<p>Java NIO引入了两个新的概念：通道Channel和选择器Selector；<br>通道是服务端和客户端进行通信的接口——-原来是直接的IO操作，客户端发信息给服务端，服务端从OutputStream中读取，然后向InputStream中写数据；现在则直接从Channel中读取或写入数据；<br>选择器是一个多路复用器：所有的通道向它注册事件，因此它管理了所有的通道信息，并轮询各个通道的状态，一旦某个通道某事件发生（比如有数据读或可以写入数据），则通知该管道对应事件的处理器去处理它；<br>如下图所示：</p>
<p>客户端连接上服务端后，首先每个客户端都要与服务端建立一个通道（SocketChannel）；然后每个通道向选择器(Selector)注册事件，注册器就会轮询查看每个通道是否有事件发生，一旦某通道有事件发生，比如Client1的SocketChannel有数据了，就触发了读就绪事件，可以进行读取的操作啦。</p>
<p>Reactor模式和NIO<br>当前分布式计算　Web Services盛行天下，这些网络服务的底层都离不开对socket的操作。他们都有一个共同的结构：</p>
<ol>
<li>Read request</li>
<li>Decode request</li>
<li>Process service</li>
<li>Encode reply</li>
<li>Send reply<br>经典的网络服务的设计如下图，在每个线程中完成对数据的处理：</li>
</ol>
<p>但这种模式在用户负载增加时，性能将下降非常的快。我们需要重新寻找一个新的方案，保持数据处理的流畅，很显然，事件触发机制是最好的解决办法，当有事件发生时，会触动handler,然后开始数据的处理。<br>Reactor模式类似于AWT中的Event处理：</p>
<p>Reactor模式参与者<br>1.Reactor 负责响应IO事件，一旦发生，广播发送给相应的Handler去处理,这类似于AWT的thread<br>2.Handler 是负责非堵塞行为，类似于AWT ActionListeners；同时负责将handlers与event事件绑定，类似于AWT addActionListener<br>如图：</p>
<p>Java的NIO为reactor模式提供了实现的基础机制，它的Selector当发现某个channel有数据时，会通过SlectorKey来告知我们，在此我们实现事件和handler的绑定。</p>
<p>我们来看看Reactor模式代码:</p>
<p>public class Reactor implements Runnable{<br>　　final Selector selector;<br>　　final ServerSocketChannel serverSocket;<br>　　Reactor(int port) throws IOException {<br>　　　　selector = Selector.open();<br>　　　　serverSocket = ServerSocketChannel.open();<br>　　　　InetSocketAddress address = new InetSocketAddress(InetAddress.getLocalHost(),port);<br>　　　　serverSocket.socket().bind(address);</p>
<p>　　　　serverSocket.configureBlocking(false);<br>　　　　//向selector注册该channel<br>　　　　 SelectionKey sk =serverSocket.register(selector,SelectionKey.OP_ACCEPT);</p>
<p>　　　　logger.debug(“—&gt;Start serverSocket.register!”);</p>
<p>　　　　//利用sk的attache功能绑定Acceptor 如果有事情，触发Acceptor<br>　　　　sk.attach(new Acceptor());<br>　　　　logger.debug(“—&gt;attach(new Acceptor()!”);<br>　　}</p>
<p>　　public void run() { // normally in a new Thread<br>　　　　try {<br>　　　　while (!Thread.interrupted())<br>　　　　{<br>　　　　　　selector.select();<br>　　　　　　Set selected = selector.selectedKeys();<br>　　　　　　Iterator it = selected.iterator();<br>　　　　　　//Selector如果发现channel有OP_ACCEPT或READ事件发生，下列遍历就会进行。<br>　　　　　　while (it.hasNext())<br>　　　　　　　　//来一个事件 第一次触发一个accepter线程<br>　　　　　　　　//以后触发SocketReadHandler<br>　　　　　　　　dispatch((SelectionKey)(it.next()));<br>　　　　　　　　selected.clear();<br>　　　　　　}<br>　　　　}catch (IOException ex) {<br>　　　　　　　　logger.debug(“reactor stop!”+ex);<br>　　　　}<br>　　}<br>　　//运行Acceptor或SocketReadHandler<br>　　void dispatch(SelectionKey k) {<br>　　　　Runnable r = (Runnable)(k.attachment());<br>　　　　if (r != null){<br>　　　　　　// r.run();<br>　　　　}<br>　　}<br>　　class Acceptor implements Runnable { // inner<br>　　　　public void run() {<br>　　　　try {<br>　　　　　　logger.debug(“—&gt;ready for accept!”);<br>　　　　　　SocketChannel c = serverSocket.accept();<br>　　　　　　if (c != null)<br>　　　　　　　　//调用Handler来处理channel<br>　　　　　　　　new SocketReadHandler(selector, c);<br>　　　　　　}<br>　　　　catch(IOException ex) {<br>　　　　　　logger.debug(“accept stop!”+ex);<br>　　　　}<br>　　　　}<br>　　}<br>}<br>以上代码中巧妙使用了SocketChannel的attach功能，将Hanlder和可能会发生事件的channel链接在一起，当发生事件时，可以立即触发相应链接的Handler。<br>再看看Handler代码:<br>public class SocketReadHandler implements Runnable {<br>　　public static Logger logger = Logger.getLogger(SocketReadHandler.class);<br>　　private Test test=new Test();<br>　　final SocketChannel socket;<br>　　final SelectionKey sk;</p>
<p>　　 static final int READING = 0, SENDING = 1;<br>　　int state = READING;<br>　　public SocketReadHandler(Selector sel, SocketChannel c)<br>　　　　throws IOException {<br>　　　　socket = c;<br>　　　　socket.configureBlocking(false);<br>　　　　 sk = socket.register(sel, 0);<br>　　　　//将SelectionKey绑定为本Handler 下一步有事件触发时，将调用本类的run方法。<br>　　　　//参看dispatch(SelectionKey k)<br>　　　　sk.attach(this);</p>
<p>　　　　//同时将SelectionKey标记为可读，以便读取。<br>　　　　sk.interestOps(SelectionKey.OP_READ);<br>　　　　sel.wakeup();<br>　　}<br>　　public void run() {<br>　　　　try{<br>　　　　// test.read(socket,input);<br>　　　　　　readRequest() ;<br>　　　　}catch(Exception ex){<br>　　　　logger.debug(“readRequest error”+ex);<br>　　　　}<br>　　}</p>
<p>/**</p>
<ul>
<li>处理读取data</li>
<li>@param key</li>
<li>@throws Exception<br>*/<br>private void readRequest() throws Exception {<br>　　ByteBuffer input = ByteBuffer.allocate(1024);<br>　　input.clear();<br>　　try{<br>　　　　int bytesRead = socket.read(input);<br>　　　　……<br>　　　　//激活线程池 处理这些request<br>　　　　requestHandle(new Request(socket,btt));<br>　　　　…..</li>
</ul>
<p>　　}catch(Exception e) {<br>　　}</p>
<p>}<br>注意在Handler里面又执行了一次attach，这样，覆盖前面的Acceptor，下次该Handler又有READ事件发生时，将直接触发Handler.从而开始了数据的读　处理　写　发出等流程处理。</p>
<p>将数据读出后，可以将这些数据处理线程做成一个线程池，这样，数据读出后，立即扔到线程池中，这样加速处理速度：</p>
<p>更进一步，我们可以使用多个Selector分别处理连接和读事件。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sakuyayc.github.io/sakuyayc/2015/07/22/MINA软件架构介绍介绍/" data-id="ciceshp6m00035draq0kgyv63" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/sakuyayc/2015/07/20/helloworld-1/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">helloworld!</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  
    
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/sakuyayc/archives/2015/07/">July 2015</a><span class="archive-list-count">5</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/sakuyayc/2015/07/22/MINA软件架构介绍介绍/">MINA软件架构介绍介绍</a>
          </li>
        
          <li>
            <a href="/sakuyayc/2015/07/20/helloworld-1/">helloworld!</a>
          </li>
        
          <li>
            <a href="/sakuyayc/2015/07/20/helloworld/">helloworld</a>
          </li>
        
          <li>
            <a href="/sakuyayc/2015/07/20/My-New-Post/">My New Post</a>
          </li>
        
          <li>
            <a href="/sakuyayc/2015/07/19/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 Yang Chao<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="http://cdn.bootcss.com/jquery/2.1.1/jquery.min.js"></script>


  <link rel="stylesheet" href="/sakuyayc/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/sakuyayc/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/sakuyayc/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>