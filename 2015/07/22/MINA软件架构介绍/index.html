<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>MINA软件架构介绍 | 杨超的程序世界</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="MINA 项目介绍简介Apache MINA(Multipurpose Infrastructure for Network Applications) 是 Apache 组织的一个较新的项目，它为开发高性能和高可用性的网络应用程序提供了非常便利的框架。当前发行的 MINA 版本提供了一个通过Java NIO在不同的传输例如TCP/IP和UDP/IP上抽象的事件驱动的异步API。
目前正在使用 M">
<meta property="og:type" content="article">
<meta property="og:title" content="MINA软件架构介绍">
<meta property="og:url" content="http://sakuyayc.github.io/sakuyayc/2015/07/22/MINA软件架构介绍/index.html">
<meta property="og:site_name" content="杨超的程序世界">
<meta property="og:description" content="MINA 项目介绍简介Apache MINA(Multipurpose Infrastructure for Network Applications) 是 Apache 组织的一个较新的项目，它为开发高性能和高可用性的网络应用程序提供了非常便利的框架。当前发行的 MINA 版本提供了一个通过Java NIO在不同的传输例如TCP/IP和UDP/IP上抽象的事件驱动的异步API。
目前正在使用 M">
<meta property="og:image" content="http://7xknqk.com1.z0.glb.clouddn.com/pic1.png">
<meta property="og:image" content="http://7xknqk.com1.z0.glb.clouddn.com/pic2.png">
<meta property="og:image" content="http://7xknqk.com1.z0.glb.clouddn.com/pic3.png">
<meta property="og:image" content="http://7xknqk.com1.z0.glb.clouddn.com/pic4.png">
<meta property="og:image" content="http://7xknqk.com1.z0.glb.clouddn.com/pic5.png">
<meta property="og:image" content="http://7xknqk.com1.z0.glb.clouddn.com/pic6.png">
<meta property="og:image" content="http://7xknqk.com1.z0.glb.clouddn.com/pic7.png">
<meta property="og:image" content="http://7xknqk.com1.z0.glb.clouddn.com/pic8.png">
<meta property="og:image" content="http://7xknqk.com1.z0.glb.clouddn.com/pic9.png">
<meta property="og:image" content="http://7xknqk.com1.z0.glb.clouddn.com/pic10.png">
<meta property="og:image" content="http://7xknqk.com1.z0.glb.clouddn.com/pic11.png">
<meta property="og:image" content="http://7xknqk.com1.z0.glb.clouddn.com/pic12.png">
<meta property="og:image" content="http://7xknqk.com1.z0.glb.clouddn.com/pic13.png">
<meta property="og:image" content="http://7xknqk.com1.z0.glb.clouddn.com/pic14.png">
<meta property="og:image" content="http://7xknqk.com1.z0.glb.clouddn.com/pic15.png">
<meta property="og:image" content="http://7xknqk.com1.z0.glb.clouddn.com/pic16.png">
<meta property="og:image" content="http://7xknqk.com1.z0.glb.clouddn.com/pic17.png">
<meta property="og:image" content="http://7xknqk.com1.z0.glb.clouddn.com/pic18.png">
<meta property="og:image" content="http://7xknqk.com1.z0.glb.clouddn.com/pic19.png">
<meta property="og:image" content="http://7xknqk.com1.z0.glb.clouddn.com/pic20.png">
<meta property="og:image" content="http://7xknqk.com1.z0.glb.clouddn.com/pic21.png">
<meta property="og:updated_time" content="2015-07-26T08:20:44.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MINA软件架构介绍">
<meta name="twitter:description" content="MINA 项目介绍简介Apache MINA(Multipurpose Infrastructure for Network Applications) 是 Apache 组织的一个较新的项目，它为开发高性能和高可用性的网络应用程序提供了非常便利的框架。当前发行的 MINA 版本提供了一个通过Java NIO在不同的传输例如TCP/IP和UDP/IP上抽象的事件驱动的异步API。
目前正在使用 M">
  
    <link rel="alternative" href="/atom.xml" title="杨超的程序世界" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/sakuyayc/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">杨超的程序世界</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">数据可视化、分布式、软件工程</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://sakuyayc.github.io/sakuyayc"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-MINA软件架构介绍" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/sakuyayc/2015/07/22/MINA软件架构介绍/" class="article-date">
  <time datetime="2015-07-22T13:06:03.000Z" itemprop="datePublished">2015-07-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      MINA软件架构介绍
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="MINA_项目介绍">MINA 项目介绍</h1><h2 id="简介">简介</h2><p>Apache MINA(Multipurpose Infrastructure for Network Applications) 是 Apache 组织的一个较新的项目，它为开发高性能和高可用性的网络应用程序提供了非常便利的框架。当前发行的 MINA 版本提供了一个通过Java NIO在不同的传输例如TCP/IP和UDP/IP上抽象的事件驱动的异步API。</p>
<p>目前正在使用 MINA 的软件包括有：Apache Directory Project、AsyncWeb、AMQP（Advanced Message Queuing Protocol）、RED5 Server（Macromedia Flash Media RTMP）、ObjectRADIUS、Openfire 等等。</p>
<p>MINA虽然简单但是仍然提供了全功能的网络应用程序框架：(以下内容出自<a href="http://mina.apache.org/features.html" target="_blank" rel="external">http://mina.apache.org/features.html</a>)</p>
<ul>
<li>为不同的传输类型提供了统一的API:<ul>
<li>通过Java NIO提供TCP/IP 和 UDP/IP支持</li>
<li>通过RXTX提供串口通讯(RS232)</li>
<li>In-VM管道通讯</li>
<li>你能实现你自己的API!</li>
</ul>
</li>
<li>过滤器作为一个扩展特性; 类似Servlet过滤器</li>
<li>低级和高级的API:<ul>
<li>低级: 使用字节缓存(ByteBuffers)</li>
<li>高级: 使用用户定义的消息对象(objects)和编码(codecs)</li>
</ul>
</li>
<li>高度定制化线程模型:<ul>
<li>单线程</li>
<li>一个线程池</li>
<li>一个以上的线程池(也就是SEDA)</li>
</ul>
</li>
<li>使用Java 5 SSL引擎提供沙盒(Out-of-the-box) SSL · TLS · StartTLS支持</li>
<li>超载保护和传输流量控制</li>
<li>利用模拟对象进行单元测试</li>
<li>JMX管理能力</li>
<li>通过StreamIoHandler提供基于流的I/O支持</li>
<li>和知名的容器(例如PicoContainer、Spring)集成</li>
<li>从Netty平滑的迁移到MINA， Netty是MINA的前辈。</li>
</ul>
<h2 id="源代码">源代码</h2><p>MINA通过MAVEN管理项目，所以需要查看源代码的话最好需要MAVEN环境。通过pom.xml将项目导入eclipse即可查看代码，如下如所示：</p>
<p><img src="http://7xknqk.com1.z0.glb.clouddn.com/pic1.png" alt="pic1" title="no title"></p>
<p>本文主要分析mina-core这个项目下面的内容。</p>
<h1 id="MINA_静态分析">MINA 静态分析</h1><h2 id="概述">概述</h2><p><img src="http://7xknqk.com1.z0.glb.clouddn.com/pic2.png" alt="pic2" title="no title"></p>
<p>如上图所示，Mina处于应用层和底层之间，它不关心底层网络数据如何传输，只负责接收底层数据，过滤并转换为Java对象提供给我们的应用程序，然后把应用程序响应值过滤并转换为底层识别的字节，提供给底层传输。 </p>
<p>Mina工作流程图如下：</p>
<p><img src="http://7xknqk.com1.z0.glb.clouddn.com/pic3.png" alt="pic3" title="no title"></p>
<p>这个流程图可以直观的看出Mina的工作流程，同时也涵盖了Mina的三个核心接口:IoService接口，IoFilter接口和IoHandler接口：<br>IoService接口实现了创建服务对象（客户端或服务端），把JAVA的NIO部分进行封装，向外提供简洁API。<br>IoFilter接口是比较关键的部分，它可以进行日志记录，信息过滤，编码解码等操作，把数据接收发送从业务层独立出来。<br>IoHandler接口是业务应用最关心的部分，用户需要根据需要自己实现。</p>
<p>根据官方文档，在整个框架比较重要的几个包是：<br>org.apache.mina.core.service,org.apache.mina.core.session,<br>org.apache.mina.core.polling 以及org.apache.mina.transport.socket。</p>
<p><img src="http://7xknqk.com1.z0.glb.clouddn.com/pic4.png" alt="pic4" title="no title"></p>
<p>我们先来看org.apache.mina.core.service这个包</p>
<h2 id="org-apache-mina-core-service">org.apache.mina.core.service</h2><h3 id="IoService接口">IoService接口</h3><p>IoService是创建服务的顶层接口，是对于服务器端的接受连接和客户端发起连接这两种行为的抽象。无论客户端还是服务端，都是从它继承实现的。<br>常用接口为：IoService，IoAcceptor，IoConnector<br>常用类为：NioSocketAcceptor，NioSocketConnector</p>
<p>类图如下：<br><img src="http://7xknqk.com1.z0.glb.clouddn.com/pic5.png" alt="pic5" title="no title"></p>
<ul>
<li>IoService接口声明了服务端的共有属性和行为；</li>
<li>IoAcceptor接口继承了IoService接口，并添加了服务端特有的接口属性及方法，比如bind（）方法，成为典型的服务端接口；</li>
<li>IoConnector接口同样继承了IoService接口，并添加了客户端特有的接口属性及方法，比如connect（）方法，成为典型的客户端接口； </li>
<li>AbstractIoService实现了IoService中管理服务的方法，比如getFilterChainBuilder方法—获得过滤器链；</li>
<li>AbstractIoService抽象类继承了AbstractIoService抽象类并实现了IoAcceptor接口，成为了拥有管理服务端实现功能的服务端类；我们常用的NioSocketAcceptor就是它的子类；</li>
<li>AbstractIoConnector抽象类继承了AbstractIoService抽象类并实现了IoConnector接口，成为了拥有管理客户端实现功能的客户端类；我们常用的NioSocketConnector就是它的子类；</li>
</ul>
<p>IoService是创建服务端和客户端的接口，实际应用中我们大多都是应用它的实现类来创建服务对象。需要注意的是，开发客户端还是服务端的时候IoService起到的作用并不完全一样，具体可以参考本文动态运行分析部分。</p>
<h3 id="IoFilter接口">IoFilter接口</h3><p>可以说，Mina最主要的工作就是把底层传输的字节码转换为Java对象，提供给应用程序；或者把应用程序返回的结果转换为字节码，交给底层传输。这些转化的工作都是由IoFilter完成的。IoFilter和Servlet中的过滤器一样，主要用于拦截和过滤网络传输中I/O操作的各种消息。</p>
<p>在Mina 的官方文档中已经提到了IoFilter 的作用：</p>
<ul>
<li>记录事件的日志（Mina默认提供了LoggingFilter）</li>
<li>测量系统性能</li>
<li>信息验证</li>
<li>过载控制</li>
<li>信息的转换(主要就是编码和解码)</li>
<li>和其他更多的信息</li>
</ul>
<p>IoService实例会绑定一个DefaultIoFilterChainBuilder —— 过滤器链，我们可以把自定义的各种过滤器（IoFilter）插入这个过滤器链上。<br>常用接口为：IoFilter, IoFilterChainBuilder<br>常用类为：IoFilterAdapter, DefaultIoFilterChainBuilder, ProtocolCodecFilter, LoggingFilter</p>
<p>类图如下：</p>
<p><img src="http://7xknqk.com1.z0.glb.clouddn.com/pic6.png" alt="pic6" title="no title"></p>
<ol>
<li><p>IoFilter有2个实现类：IoFilterAdapter是个抽象的适配器类，我们可以根据需要扩展这个类，并且有选择的覆盖过滤器的方法；所有方法的默认把事件转发到下一个过滤器：</p>
<pre><code><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">sessionOpened</span><span class="params">(NextFilter nextFilter, IoSession session)</span><span class="keyword">throws</span> Exception </span>{
    nextFilter.sessionOpened(session);
}
</code></pre></li>
<li><p>ReferenceCountingFilter封装了IoFilter实例，监看调用该filter的对象的个数，如果没有任何对象调用该IoFilter，就自动销毁IoFilter：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingFilter</span> <span class="keyword">implements</span> <span class="title">IoFilter</span> </span>{
    <span class="keyword">private</span> <span class="keyword">final</span> IoFilter filter;

    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;

    <span class="function"><span class="keyword">public</span> <span class="title">ReferenceCountingFilter</span><span class="params">(IoFilter filter)</span> </span>{
        <span class="keyword">this</span>.filter = filter;
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{
        <span class="comment">// no-op, will init on-demand in pre-add if count == 0</span>
    }
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{
    } 
    <span class="comment">//……</span>
}
</code></pre></li>
<li><p>实现IoFilterAdapter的类有多个，但是我们使用最多的就是ProtocolCodecFilter——它是我们自定义编解码器的入口。在实际的应用开发中，很多客户端和服务端是不同语言实现的，所以自定义协议经常会用到。</p>
</li>
</ol>
<h2 id="IoHandler接口">IoHandler接口</h2><p>IoHandle接口，Mina中的所有I/O事件都是通过这个接口来处理的，在IoHandler中定义了7个方法，根据I/O事件来触发对应的方法：</p>
<p>在IoHandler中定义了7个方法，根据I/O事件来触发对应的方法：</p>
<pre><code><span class="keyword">import</span> java.io.IOException;
<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IoHandler</span> </span>{
    <span class="function"><span class="keyword">void</span> <span class="title">sessionCreated</span><span class="params">(IoSession session)</span> <span class="keyword">throws</span> Exception</span>;
    <span class="function"><span class="keyword">void</span> <span class="title">sessionOpened</span><span class="params">(IoSession session)</span> <span class="keyword">throws</span> Exception</span>;
    <span class="function"><span class="keyword">void</span> <span class="title">sessionClosed</span><span class="params">(IoSession session)</span> <span class="keyword">throws</span> Exception</span>;
    <span class="function"><span class="keyword">void</span> <span class="title">sessionIdle</span><span class="params">(IoSession session, IdleStatus status)</span> <span class="keyword">throws</span> Exception</span>;
    <span class="function"><span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(IoSession session, Throwable cause)</span> <span class="keyword">throws</span> Exception</span>;
    <span class="function"><span class="keyword">void</span> <span class="title">messageReceived</span><span class="params">(IoSession session, Object message)</span> <span class="keyword">throws</span> Exception</span>;
    <span class="function"><span class="keyword">void</span> <span class="title">messageSent</span><span class="params">(IoSession session, Object message)</span> <span class="keyword">throws</span> Exception</span>;
}
</code></pre><p>sessionCreated:当一个新的连接建立时，由I/O processor thread调用；<br>sessionOpened:当连接打开是调用；<br>messageReceived:当接收了一个消息时调用；<br>messageSent：当一个消息被(IoSession#write)发送出去后调用；<br>sessionIdle:当连接进入空闲状态时调用；<br>sessionClosed:当连接关闭时调用；<br>exceptionCaught:当实现IoHandler的类抛出异常时调用；</p>
<p>上述IoHandler的这7个方法其实是根据session的4个状态值间变化来调用的：</p>
<ul>
<li>Connected：会话被创建并使用；</li>
<li>Idle：会话在一段时间(可配置)内没有任何请求到达，进入空闲状态；</li>
<li>Closing：会话将被关闭（剩余message将被强制flush）；</li>
<li>Closed：会话被关闭；</li>
</ul>
<p>状态转换图如下：</p>
<p><img src="http://7xknqk.com1.z0.glb.clouddn.com/pic7.png" alt="pic7" title="no title"></p>
<p>一般情况下，我们关心的只有messageReceived方法，接收消息并处理，然后调用IoSession的write方法发送出消息。<br>一般情况下很少有人实现IoHandler接口，而是继承它的一个实现类IoHandlerAdapter，这样不用覆盖它的7个方法，只需要根据具体需求覆盖其中的某几个方法。</p>
<h2 id="org-apache-mina-core-session">org.apache.mina.core.session</h2><p>org.apache.mina.core.session这个包主要是围绕IoSession展开的，包括会话的方方面面。IoSession接口与底层的传输层类型无关（也就是不管是TCP还是UDP）,它表示通信双端的连接。它提供用户自定义属性，可以用于在过滤器和处理器之间交换用户自定义协议相关的信息。每个会话都有一个Service为之提供服务，同时有一个Handler负责此会话的I/O事件处理。最重要的两个方法是read和write，这两个方法都是异步执行，若要真正完成必须在其返回结果上进行等待。关闭会话的方法close是异步执行的，也就是应当等待返回的CloseFuture。会话的读写类型是可配置的，在运行中可设置此端是否可读写。<br>一个会话主要包含两个方面的数据，属性映射图，写请求队列，在这里作者使用了工厂模式来为新创建的会话提供这些数据结构。</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IoSession</span> <span class="title">DataStructureFactory</span>
</span>{
    <span class="function">IoSessionAttributeMap <span class="title">getAttributeMap</span><span class="params">(IoSession session)</span> <span class="keyword">throws</span> Exception</span>;
    <span class="function">WriteRequestQueue <span class="title">getWriteRequestQueue</span><span class="params">(IoSession session)</span> <span class="keyword">throws</span> Exception</span>;
}
</code></pre><p>IoSessionConfig接口用于表示会话的配置信息，主要包括：读缓冲区大小，会话数据吞吐量，计算吞吐量时间间隔，指定会话端的空闲时间，写请求操作超时时间。<br>MINA的会话中，有三种类型的闲置状态：1）READER_IDLE，这表示从远端没有数据到来，读端空闲。2）WRITER_IDLE，这表示写端没有在写数据。3）BOTH_IDLE，读端和写端都空闲。为了节约会话资源，可以让用户设置当空闲超过一定时间后关闭此会话，因为此会话可能在某一端出问题了，从而导致另一端空闲超过太长时间。这可以通过使用IoSessionConfig.setIdleTime(IdleStatus,int)来完成，空闲时间阀值在会话配（IoSessionConfig）中设置。<br>前面介绍过IoSessionDataStructureFactor接口为会话提供所需要的数据结构，DefaultIoSessionDataStructureFactory是其一个默认实现类。</p>
<h2 id="org-apache-mina-core-polling">org.apache.mina.core.polling</h2><p>这个包里包含了实现基于轮询策略（比如NIO的select调用或其他类型的I/O轮询系统调用（如epoll,poll,kqueue等）的基类。<br>AbstractPollingIoAcceptor这个抽象基类继承自AbstractIoAcceptor。底层的sockets会被不断检测，并当有任何一个socket需要被处理时就会被唤醒去处理。这个类封装了服务器端socket的bind,accept和dispose等动作，其成员变量Executor负责接受来自客户端的连接请求，另一个AbstractPollingIoProcessor用于处理客户端的I/O操作请求，如读写和关闭连接。<br>AbstractPollingIoConnector用于实现客户端连接的轮询策略。处理逻辑基本上和上文所说的AbstractPollingIoAcceptor类似。</p>
<h1 id="MINA_动态分析">MINA 动态分析</h1><h2 id="NIO分析">NIO分析</h2><p>首先，Mina是一个Java NIO框架，Java NIO(new IO)是JDK1.4引入的非阻塞IO机制，NIO的基本思想是：服务器程序只需要一个线程就能同时负责接收客户的连接、客户发送的数据，以及向各个客户发送响应数据。<br>Java NIO引入了两个新的概念：通道Channel和选择器Selector；<br>通道Channel是服务端和客户端进行通信的接口（原来是直接的IO操作，客户端发信息给服务端，服务端从OutputStream中读取，然后向InputStream中写数据；现在则直接从Channel中读取或写入数据）。<br>选择器Selector是一个多路复用器：所有的通道向它注册事件，因此它管理了所有的通道信息，并轮询各个通道的状态，一旦某个通道某事件发生（比如有数据读或可以写入数据），则通知该管道对应事件的处理器去处理它；<br>如下图所示：</p>
<p><img src="http://7xknqk.com1.z0.glb.clouddn.com/pic8.png" alt="pic8" title="no title"></p>
<p>客户端连接上服务端后，首先每个客户端都要与服务端建立一个通道（SocketChannel）；然后每个通道向选择器(Selector)注册事件，注册器就会轮询查看每个通道是否有事件发生，一旦某通道有事件发生，比如Client1的SocketChannel有数据了，就触发了读就绪事件，Handler就可以进行读取的操作。<br>先介绍下NIO的几个常用类：</p>
<h3 id="Buffer_缓冲区">Buffer 缓冲区</h3><p>Java NIO的缓冲区Buffer基本和Mina的IoBuffer一样，但是准确的说，Mina的IoBuffer就是对Java NIO buffer的二次封装，使得它的功能更加强大。<br>数据输入和输出往往是比较耗时的操作。缓冲区从两个方面提高I/O操作的效率：</p>
<ul>
<li>减少实际的物理读写次数。这一点比较容易理解，我们经常使用的缓冲数组就是这个道理</li>
<li>缓冲区在创建时被分配内存，这块内存区域一直被重用，这可以减少动态分配和回收内存区域的次数。</li>
</ul>
<p>这一点是Buffer的优势，也是buffer性能较高的一个原因。 </p>
<p><img src="http://7xknqk.com1.z0.glb.clouddn.com/pic9.png" alt="pic9" title="no title"></p>
<p>java.nio.Buffer类是一个抽象类，不能被实例化。共有8个具体的缓冲区类，其中最基本的缓冲区是ByteBuffer，它存放的数据单元是字节。ByteBuffer类并没有提供公开的构造方法，但是提供了两个获得ByteBuffer实例的静态工厂方法：</p>
<ul>
<li>allocate(int capacity)：返回一个ByteBuffer对象，参数capacity指定缓冲区的容量。</li>
<li>directAllocate(int capacity): 返回一个ByteBuffer对象，参数capacity指定缓冲区的容量。该方法返回的缓冲区称为直接缓冲区，它与当前操作系统能够更好的耦合，因此能进一步提高I/O操作的速度。但是分配直接缓冲区的系统开销很大，因此只有在缓冲区较大并且长期存在，或者需要经常重用时，才使用这种缓冲区。</li>
</ul>
<h3 id="Charset_字符编码">Charset 字符编码</h3><p>Charset就是根据指定的编码个数进行编解码的一个接口，不多作解释。</p>
<h3 id="Channel_通道">Channel 通道</h3><p>通道在Java NIO的开始就做个解释，它是服务端和客户端进行通信的接口；通道Channel用来连接缓冲区与数据源或数据汇（即数据目的地）。如下图所示，数据源的数据经过通道到达缓冲区，缓冲区的数据经过通道到达数据汇。</p>
<p><img src="http://7xknqk.com1.z0.glb.clouddn.com/pic10.png" alt="pic10" title="no title"></p>
<p>但是在实际的开发中，我们基本都是使用Channel的实现类：ServerSocketChannel和SocketChannel，类图如下：<br><img src="http://7xknqk.com1.z0.glb.clouddn.com/pic11.png" alt="pic11" title="no title"></p>
<p>ServerSocketChannel从SelectableChannel中继承了configureBlocking()和register()方法。ServerSocketChannel是ServerSocket的替代类，也具有负责接收客户连接的accept()方法；<br>ServerSocketChannel并没有public类型的构造方法，必须通过它的静态方法open()来创建ServerSocketChannel对象；<br>每个ServerSocketChannel对象都与一个ServerSocket对象关联。ServerSocketChannel的socket()方法返回与它关联的ServerSocket对象；</p>
<pre><code>private Selector selector;
private int PORT = <span class="number">3015</span>;
private ServerSocketChannel serverSocketChannel = null;
<span class="comment">// 创建一个Selector对象</span>
selector = Selector.open<span class="params">()</span>;
<span class="comment">// 创建一个ServerSocketChannel对象</span>
serverSocketChannel = ServerSocketChannel.open<span class="params">()</span>;
<span class="comment">// 使得在同一个主机上关闭了服务器程序，紧接着再启动该服务器程序时，</span>
<span class="comment">// 可以顺利绑定到相同的端口</span>
serverSocketChannel.socket<span class="params">()</span>.setReuseAddress<span class="params">(<span class="literal">true</span>)</span>;
<span class="comment">// 使ServerSocketChannel工作于非阻塞模式</span>
serverSocketChannel.configureBlocking<span class="params">(<span class="literal">false</span>)</span>;
serverSocketChannel.socket<span class="params">()</span>.bind<span class="params">(new InetSocketAddress<span class="params">(PORT)</span>)</span>;
</code></pre><p>SocketChannel可看作是Socket的替代类，但它比Socket具有更多的功能；SocketChannel不仅从SelectableChannel父类中继承了configureBlocking()和register()方法，而且实现了ByteChannel接口，因此具有用于读写数据的read(ByteBuffer dst)和write(ByteBuffer src)方法；<br>SocketChannel没有public类型的构造方法，必须通过它的静态方法open()来创建SocketChannel对象。</p>
<pre><code><span class="keyword">private</span> <span class="keyword">String</span> HOST = <span class="string">"127.0.0.1"</span>;
<span class="keyword">private</span> <span class="built_in">int</span> PORT = <span class="number">3015</span>;
<span class="keyword">private</span> SocketChannel socketChannel = <span class="keyword">null</span>;
<span class="comment">// 创建一个SocketChannel对象</span>
socketChannel = SocketChannel.<span class="built_in">open</span>();
<span class="comment">// 使SocketChannel工作于非阻塞模式</span>
socketChannel.configureBlocking(<span class="keyword">false</span>);
<span class="comment">// InetAddress ia = InetAddress.getLocalHost();</span>
<span class="comment">// InetSocketAddress isa = new InetSocketAddress(ia, 3015);</span>
InetSocketAddress isa = <span class="keyword">new</span> InetSocketAddress(HOST, PORT);
socketChannel.connect(isa);
logger.info(<span class="string">"与服务器建立连接成功...."</span>);
<span class="comment">// 创建一个Selector对象</span>
selector = Selector.<span class="built_in">open</span>();
</code></pre><h3 id="Selector_选择器">Selector 选择器</h3><p>选择器就是一个多路复用器，所有的通道向它注册事件；只要ServerSocketChannel以及SocketChannel向Selector注册了特定的事件，Selector就会监控这些事件是否发生。<br>ServerSocketChannel以及SelectableChannel的register()方法负责注册事件，该方法返回一个SelectionKey对象，该对象是用于跟踪这些被注册事件的句柄。<br>在SelectionKey对象的有效期间，Selector会一直监控与SelectionKey对象相关的事件，如果事件发生，就会把SelectionKey对象加入到selected-keys集合中。<br>在以下情况，SelectionKey对象会失效，这意味着Selector再也不会监控与它相关的事件:</p>
<ol>
<li>程序调用SelectionKey的cancel()方法；</li>
<li>关闭与SelectionKey关联的Channel；</li>
<li>与SelectionKey关联的Selector被关闭；</li>
</ol>
<p>在SelectionKey中定义了四种事件，分别用4个int类型的常量来表示：</p>
<ul>
<li>SelectionKey.OP_ACCEPT：接收连接就绪事件，表示服务器监听到了客户连接，服务器可以接收这个连接了。常量值为16</li>
<li>SelectionKey.OP_CONNECT：连接就绪事件，表示客户与服务器的连接已经建立成功。常量值为8。</li>
<li>SelectionKey.OP_READ：读就绪事件，表示通道中已经有了可读数据，可以执行读操作了。常量值为1。</li>
<li>SelectionKey.OP_WRITE：写就绪事件，表示已经可以向通道写数据了。常量值为4。</li>
</ul>
<h3 id="Reactor模式">Reactor模式</h3><p>MINA为了提升效率使用了Reactor模式，而Java的NIO为Reactor模式提供了实现的基础机制。<br>经典的网络服务的设计如下图，在每个线程中完成对数据的处理：<br><img src="http://7xknqk.com1.z0.glb.clouddn.com/pic12.png" alt="pic12" title="no title"></p>
<p>但这种模式在用户负载增加时，性能将下降非常的快。<br>所以我们需要寻找一个更好的方案，保持数据处理的流畅，很显然，事件触发机制是最好的解决办法，当有事件发生时，会触动handler,然后开始数据的处理。<br>Reactor模式与AWT中的Event的处理方法类似，如下图所示：<br><img src="http://7xknqk.com1.z0.glb.clouddn.com/pic13.png" alt="pic13" title="no title"></p>
<ol>
<li>Reactor 负责响应IO事件，一旦发生，广播发送给相应的Handler去处理,这类似于AWT的thread</li>
<li>Handler 是负责非堵塞行为，类似于AWT ActionListeners；同时负责将handlers与event事件绑定，类似于AWT addActionListener</li>
</ol>
<p>我们根据上述架构修改socket的结构，如图：<br><img src="http://7xknqk.com1.z0.glb.clouddn.com/pic14.png" alt="pic14" title="no title"></p>
<p>Java的NIO为reactor模式提供了实现的基础机制，它的Selector当发现某个channel有数据时，会通过SlectorKey来告知我们，在此我们实现事件和handler的绑定。<br>为了进一步提高效率我们可以将数据处理的线程做成一个线程池，这样，数据读出后，立即扔到线程池中，这样加速处理速度：<br><img src="http://7xknqk.com1.z0.glb.clouddn.com/pic15.png" alt="pic15" title="no title"></p>
<p>再次分析，我们可以发现这样的单独一个Selector承载了太多的压力，为了令效率更进一步，我们可以使用多个Selector分别处理连接和读事件。<br><img src="http://7xknqk.com1.z0.glb.clouddn.com/pic16.png" alt="pic16" title="no title"></p>
<p>如果再继续挖掘NIO的特性提升该架构的效能，可能存在方向：</p>
<ol>
<li>每个Reactor都有多个Selector；</li>
<li>文件传输；</li>
<li>文件保存至内存；</li>
<li>直接保存内存，而不是用JAVA虚拟机的虚拟内存。</li>
</ol>
<h2 id="Mina架构解析">Mina架构解析</h2><p><img src="http://7xknqk.com1.z0.glb.clouddn.com/pic17.png" alt="pic17" title="no title"></p>
<p>上图出自Peter Royal于2007年在ApacheCon的演讲<br><a href="http://www.slideshare.net/osi/apache-mina-the-highperformance-protocol-construction-toolkit" target="_blank" rel="external">http://www.slideshare.net/osi/apache-mina-the-highperformance-protocol-construction-toolkit</a></p>
<p>下面分别从客户端和服务端的角度来看：</p>
<h3 id="基于MINA架构的客户端">基于MINA架构的客户端</h3><p><img src="http://7xknqk.com1.z0.glb.clouddn.com/pic18.png" alt="pic18" title="no title"></p>
<ul>
<li>客户端先建立一个IOConnector (MINA用来连接Socket),用来连接服务端</li>
<li>连接建立以后一个Session将会被建立并且传给Connection</li>
<li>应用（或者说客户端）将数据写进Session，并且在通过Filter Chain转化后发送给服务端</li>
<li>所有从服务端发来的答复/消息会在通过Filter Chain转化后将数据交给IOHandler执行</li>
</ul>
<p>在服务器端，IoAcceptor是IoService 的子接口，它用于绑定到指定的ip和端口，从而接收来自客户端的连接请求，同时会fire相应的客户端连接成功接收/取消/失败等事件给自己的IoHandle去处理。<br>当服务器端的Accpetor从早先绑定的ip和端口上取消绑定时，默认是所有的客户端会话会被关闭，这种情况一般出现在服务器挂掉了，则客户端收到连接关闭的提示。这个接口最重要的两个方法是bind()和unbind()，当这两个方法被调用时，服务端的连接接受线程就启动或关闭了。</p>
<p><img src="http://7xknqk.com1.z0.glb.clouddn.com/pic19.png" alt="pic19" title="no title"></p>
<p>IoAcceptor的多种实现</p>
<ul>
<li>NioSocketAcceptor : 非阻塞的Socket传输Acceptor</li>
<li>NioDatagramAcceptor :非阻塞的UDP传输Acceptor</li>
<li>AprSocketAcceptor :阻塞的Socket传输Acceptor, 基于APR</li>
<li>VmPipeSocketAcceptor : in-VM Acceptor</li>
</ul>
<h3 id="基于MINA架构的服务端">基于MINA架构的服务端</h3><p><img src="http://7xknqk.com1.z0.glb.clouddn.com/pic20.png" alt="pic20" title="no title"></p>
<ul>
<li>IOAcceptor监听网络上的连接或者包</li>
<li>如果是一个新的连接，那么服务端将会新建一个 session 并且所有的从该IP地址/端口都将会在这个Session统一处理</li>
<li>所有Session收到的包都会通过Filter Chain进行转换。Filters可以修正这些包（比如转化成一个对象，或者增加/删除一些信息，等等）。 在转化成更高等级的对象时，PacketEncoder/Decoder经常会被用到。</li>
<li>最终数据包或者转化成的对象被交给了IOHandler。IOHandlers可以按需要进行相应的处理。</li>
</ul>
<p>客户端的连接发起者接口IoConnector，它的功能和IoAcceptor基本对应的，它用于尝试连接到服务器指定的ip和端口，同时会fire相应的客户端连接事件给自己的IoHandle去处理。<br>当connet方法被调用后用于连接服务器端的线程就启动了，而当所有的连接尝试都结束时线程就停止。尝试连接的超时时间可以自行设置。Connect方法返回的结果是ConnectFuture，这和前面说的WriteFuture类似，在后面会有一篇专门讲这个模式的应用。<br><img src="http://7xknqk.com1.z0.glb.clouddn.com/pic21.png" alt="pic21" title="no title"></p>
<p>IoConnector的多种实现</p>
<ul>
<li>NioSocketConnector : 非阻塞的基于Socket 的传输Connector</li>
<li>NioDatagramConnector : 非阻塞的基于UDP协议传输的 Connector</li>
<li>AprSocketConnector : 阻塞的基于Socket传输的 Connector, 基于APR</li>
<li>ProxyConnector : 一个提供代理支持的Connector</li>
<li>SerialConnector : 一个支持一系列传输的Connector</li>
<li>VmPipeConnector : in-VM Connector</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sakuyayc.github.io/sakuyayc/2015/07/22/MINA软件架构介绍/" data-id="cick63sfm0000tdrahff6pp40" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/sakuyayc/2015/07/20/My-New-Post/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">My New Post</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  
    
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/sakuyayc/archives/2015/07/">July 2015</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/sakuyayc/2015/07/22/MINA软件架构介绍/">MINA软件架构介绍</a>
          </li>
        
          <li>
            <a href="/sakuyayc/2015/07/20/My-New-Post/">My New Post</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 Yang Chao<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="http://cdn.bootcss.com/jquery/2.1.1/jquery.min.js"></script>


  <link rel="stylesheet" href="/sakuyayc/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/sakuyayc/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/sakuyayc/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>